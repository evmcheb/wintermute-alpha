# Liquidations - Tier 3
It’s DeFi Summer, and you run one of the most successful liquidators on Compound v2. On August 20, 2020, you realize that you are losing market share to [this address](https://etherscan.io/tx/0xec4f2ab36afa4fac4ba79b1ca67165c61c62c3bb6a18271c18f42a6bdfdb533d). This is odd because you updated the trading setup after [this proposal](https://compound.finance/governance/proposals/19), and have consistently won almost all liquidations since then.

- a) What’s the edge of this liquidator that allows them to win more liquidations?

Here is a dune dashboard by @jsharples with Compound liquidations, modifier to show liquidations before and after the proposal. https://dune.com/queries/4027546/6779679/97103120-7cf9-4533-8d50-dbbe3cc4e18

We can see that `0xb1340b0ce8af2def925c39cad3058167a0f36953`
and `0x7b2ef92fdecdf4a156365eb78c9e92b44588fe84`
were consistently winning liquidations until August 20. 

Neither of these addresses are including the signed oracle prices in their liquidations, instead relying on passive price oracle updates. By updating the price oracle as soon as it would make the accounts insolvent `0x888` can win more liquidations. 

`0x888` also burn gas tokens which neither address does, meaning they are able to trigger the liquidation earlier. 

- b) When you figure out the source of the edge, you notice that their calldata is extremely obfuscated. Can you explain on how the calldata works?

I used dedaub to decompile the contracts.

https://app.dedaub.com/decompile?md5=d3435ba0e835f556b073b7642d44c421

The decompiled contract is [here](./0x88886841cfccbf54adbbc0b6c9cbaceabec42b8b.sol)

Here's a summary of the calldata:
```
0x3743cb3f -> Function selector
6afae95100000000000000000000000000000000000000000000000000000034 32 -> End bytes are bitflags
0000000000000000000000000000000000000000000000000000000000000000 64 -> Expiry timestamp.
0000000000000000000000009d9b321b6398150d984de5f5be1f9bba60efaabd 96 -> The current implementation contract, XOR'd with address(this)
00000000000000000000000000000000000000000000000000000000000000a0 128 -> Offset of byte data array 1
00000000000000000000000000000000000000000000000000000000000000c0 160 -> Offset of byte data array 2
0000000000000000000000000000000000000000000000000000000000000000 192 -> Empty
0000000000000000000000000000000000000000000000000000000000000744 224 -> Length of byte data array 2
298e3e019f997ea95b77816c82878956bf2b7ad1161a3c0c875b477848ff2cbd 256 -> Encrypted calldata. Decryption algo is in decode.py
0d170e866f663dfe09334222c3cb4e021ec59386307bd0495f9ab73ea25128a6
...
77700729a07151840a456a010a9e53830cfa4f8d0a456a2081f0da19f7360909
fff86f6c00000000000000000000000000000000000000000000000000000000
```

`function 0x3743cb3f(uint256 varg0, uint256 varg1, address varg2, bytes varg3, bytes varg4) public payable;`

This function is responsible for validation on the arguments such as the size of the total calldata as well as the length of the bytes arrays.

The function then calls `0x577(bytes bvarg4, bytes bvarg3, uint256 varg2, uint256 varg1, uint256 varg0).`

`varg0` contains bitflags that control which logic gets activated.

`varg1`  is used as an expiry timestamp, unless it is 0 in which case the timestamp is not checked. I identified some of the bitflags:
- `0x3 && 0x4` - decrypt bvarg3 in memory (not used in this txn)
- `!0x1 && 0x2` - do some struct initialization with bvarg3
- `0x8` - complex revert mechanism if `map_0[keccak256('attempt/abort') ^ varg0 >> 192] is true`
- `0x10` - decrypt `varg4` in memory using a rotating XOR key.

`varg2` is the encrypted address of the current implementation contract `0x15135a5aac54aa5935f6254377d43750de2b8136`. It is decrypted by xoring with address(this). I also decompiled this using dedaub:

https://app.dedaub.com/decompile?md5=e513bbe1538e3f620f067b05d0219fd4

`varg4` is an important parameter as it contains the encrypted signatures from Coinbase. I have reversed the decryption algo in Python: [decode.py](./decode.py).
The algorithm uses the address of the implementation contract and `address(this)` to initialize an XOR key. The XOR key is rotated for each 256bit word of the encrypted calldata. 

Once the encrypted calldata has been decoded, it delegatecalls the implementation contract.

```
0x389eee82
0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643 -> cToken Liquidator Repay (cDAI)
0000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed5 -> cToken Liquidation (cETH)
00000000000000000000000026db83c03f408135933b3cff8b7adc6a7e0adebc -> borrower to be liquidated
6afae951000000000000000000000000000000000000000000000000000400c0 -> varg3
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> varg4
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> varg5
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> varg6
0000000000000000000000000000000000000000000000000000000000000160 -> bvarg7
0000000000000000000000000000000000000000000000000000000000000180 -> bvarg8
00000000000000000000000000000000000000000000000000000000000001a0 -> bvarg9 
00000000000000000000000000000000000000000000000000000000000001c0 -> bvarg10
0000000000000000000000000000000000000000000000000000000000000000 
0000000000000000000000000000000000000000000000000000000000000000 
0000000000000000000000000000000000000000000000000000000000000000 
0000000000000000000000000000000000000000000000000000000000000001 
0000000000000000000000000000000000000000000000000000000000000020 
0000000000000000000000000000000000000000000000000000000000000060 
0000000000000000000000000000000000000000000000000000000000000300 
0000000000000000000000000000000000000000000000000000000000000460
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000040
0000000000000000000000000000000000000000000000000000000000000160
0000000000000000000000000000000000000000000000000000000000000100
0000000000000000000000000000000000000000000000000000000000000080 -> Price data ETH 
000000000000000000000000000000000000000000000000000000005f3d8268
00000000000000000000000000000000000000000000000000000000000000c0
0000000000000000000000000000000000000000000000000000000017afc438
0000000000000000000000000000000000000000000000000000000000000006
7072696365730000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000003
4554480000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000100
0000000000000000000000000000000000000000000000000000000000000080 -> Price data DAI
000000000000000000000000000000000000000000000000000000005f3d8268
00000000000000000000000000000000000000000000000000000000000000c0
00000000000000000000000000000000000000000000000000000000000f5caf
0000000000000000000000000000000000000000000000000000000000000006
7072696365730000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000003
4441490000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000040
00000000000000000000000000000000000000000000000000000000000000c0
0000000000000000000000000000000000000000000000000000000000000060
d0ba2ec311667df4c2bec668b5666ce952d1373154d0393b01d937d26e19533d -> Coinbase Signature ETH
603ccf65290fa9b475064f039a41398954706c9417781de51a112fdd4d283c3d
000000000000000000000000000000000000000000000000000000000000001b
0000000000000000000000000000000000000000000000000000000000000060
fa8211125a669ec79f429a412aca359e411866c4bd35d7ab0bdb774958572632 -> Coinbase Signature DAI
7c72e5fbd9e79fee3b185a89ad228090a7026058b572ea3e3e1c0038ec97686f
000000000000000000000000000000000000000000000000000000000000001b
0000000000000000000000000000000000000000000000000000000000000002
0000000000000000000000000000000000000000000000000000000000000040
0000000000000000000000000000000000000000000000000000000000000080
0000000000000000000000000000000000000000000000000000000000000003
4554480000000000000000000000000000000000000000000000000000000000 -> "ETH
0000000000000000000000000000000000000000000000000000000000000003
4441490000000000000000000000000000000000000000000000000000000000 -> "DAI"

```

The decoded calldata contains price data and signatures from 

https://docs.cdp.coinbase.com/exchange/reference/exchangerestapi_getcoinbasepriceoracle

`varg3` of the decoded calldata acts as a bitflag to decide the exact logic flow. The source code gets too obfuscated after this for me to decipher but it appears to be performing struct initialization from the decrypted calldata. 

Essentially the function `0x389eee82` calls `postPrice` to update the price oracle, then calls `0x8f1` calls `0x1cab` which calls `liquidateBorrow` on the cToken specified in `varg0` and `varg1`

- c) Write code for the bot in Solidity, and provide all necessary information to simulate this liquidation on a mainnet fork.

I wrote the bot as a contract [08-liquidation.sol](./08-liquidation.sol) and a test script to call the contract [../test/08-liquidation.sol](../test/08-liquidation.sol)

`
forge test --match-path test/08-liquidate.sol -vvv --rpc-url https://eth.merkle.io --fork-block-number 10692539
`

```
[PASS] testLiquidation() (gas: 696552)
Logs:
  cETH balance before: 0.00000000
  DAI balance before: 100000.000000000000000000
  cETH balance after: 0.000000072662260919
  DAI balance after: 94683.813754024685207417
  we made (cETH): 726.62260919
  we paid (DAI): 5316.186245975314792583
```